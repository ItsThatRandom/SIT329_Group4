`timescale 1ns/1ns
// ----------------------------------------------------------------------------------
// TODO:
// - First iteration runs correctly in testbench, recently added the loop the following readings and 
//	 have run into issues for second loop which breaks the third as well.
//	 when trigger signal finished and waiting to recieving response, count for timing not resetting correctly? 
//
// -----------------------------------------------------------------------------------
module sensor (
  input wire clk, // 50MHz input clock
//   input inp,
//   input bidir_en, // Enable for sending.
  output [31:0] outp,
  inout bidir // Bidirectional sensor bus
);

  // Clk/Mhz management + paramaters
  reg clk_1mhz_en; // 1 MHz : 1/50 FPGA clock
  reg [6:0] clk_cnt; // clock count
  reg [20:0] cnt_1mhz; // 1 Mhz cycle count (1us)
  reg [20:0] prev_cnt; // Stores the previous cnt_1mhz value after it switches to 0.
  reg [20:0] trig_timer; // Target trigger signal time (2 Seconds).

  // Port management
  reg dout; // Data sending to sensor wire
  reg bidir_en;
  
  // Sensor related
  reg [2:0]comm_status; // [2] : response signal UP not/been recieved, [1] : response signal DOWN not/been recieved, [0] : active/inactive communication.
  reg [39:0] raw_data; // Store values before passing to output.
  reg [5:0] data_idx; // Tracks the current index to update in raw_data.
  reg [31:0] fin_data; // Validated data for output.
  reg [9:0] sum_data; // sum of data without checksum
  reg [7:0] int_checksum; // Checksum comparison
  
 

  initial begin
    
	clk_1mhz_en <= 1'b0;
    clk_cnt <= 7'b0; // Start clock counter at zero
    cnt_1mhz <= 21'b0; // Start value at zero
    prev_cnt <= 21'b0;
//     trig_timer <= 21'd1999999; // Set target trigger signal time to 2 seconds.
    trig_timer <= 21'd18001; // For testing sake, set trig far lower.
    dout <= 1;
    bidir_en <= 1; // Enable for sending.
    comm_status <= 3'b0;
    raw_data <= 40'b0;
    data_idx <= 6'd39; // Starts at lhs to mimic how its received.
    fin_data <= 32'b0;
    sum_data <= 10'b0;
    int_checksum <= 8'b11111111;
    

  end
	
  // single bus communication behaviour with sensor
  assign bidir = bidir_en ? dout : 1'bZ;
  assign outp = fin_data;

  // Clock Management for 50 Mhz to 1Mhz
  always @(posedge clk) begin
    
    // Default Assignment
    clk_1mhz_en <= 1'b0;
    
    if (clk_cnt == 49) begin
      clk_1mhz_en <= 1'b1; // Enable 1mhz to perform action (1us)
      clk_cnt <= 0; // Reset clk counter
    end
    else
      clk_cnt <= clk_cnt +1; // Increase clk counter
  end


  // Action taken every 1Mhz (1us)
  always @(posedge clk) begin  
    if (clk_1mhz_en) begin     
      
      // Trigger signal send after every 2 seconds
      if (cnt_1mhz == trig_timer) begin
        $display("Trigger signal - dropping to low for 18ms. Pre operation: cnt: %d, status: %b, H/L: %b", cnt_1mhz, comm_status, dout);
        comm_status[0] <= 1; // Set to active
        dout <= 0; // Drop low
    
      end
      
      // Already communicating
      else if (comm_status[0]) begin
        
        // WAITING TO FINISH TRIGGER SIGNAL
        if (bidir_en == 1) begin // Sender.
          
          if (cnt_1mhz == 17999) begin // Trigger signal check: waited low for 18,000us (18ms)
            $display("Trigger signal - 18ms done, raise and set to receive. cnt: %d, status: %b, H/L: %b", cnt_1mhz, comm_status, dout);
          	dout <= 1; // Set to high
            
          end
          
          // SET TO RECEIVER (has to occur one cycle after to ensure line goes high before turning receiver)
          if (prev_cnt == 18000)
            bidir_en <= 0; // Set to receiver
          else
            cnt_1mhz <= cnt_1mhz + 1; // 1 mhz count up
          
        end
        
        // AWAIT RESPONSE DOWN
        else if (comm_status[1] == 0) begin // Receiver but no response signal yet.
          if ( (prev_cnt >= 76) & (prev_cnt <= 84) & (bidir == 1)) begin// Covers the DOWN of the response 
            $display("Response signal DOWN 80us received, await 80us up. cnt: %d, status: %b, H/L: %b", cnt_1mhz, comm_status, bidir);
            comm_status[1] <= 1; // Response DOWN received
          end
          else
            cnt_1mhz <= cnt_1mhz + 1; // 1 mhz count up
        end
        
        // AWAIT RESPONSE UP
        else if (comm_status[2] == 0) begin
          if ( (prev_cnt >= 76) & (prev_cnt <= 84) & (bidir == 0)) begin // Covers the UP of the response
            $display("Response signal UP 80us received, bit transfer begins now. cnt: %d, status: %b", cnt_1mhz, comm_status);
            comm_status[2] <= 1; // Response UP received. Response signal complete
          end
          else
            cnt_1mhz <= cnt_1mhz + 1; // 1 mhz count up
        end
        
        // DATA READING: EACH BIT SET APPROPRIATE VALUE
        else if ( bidir == 0 ) begin // communcation active & response signal complete       
          
          // IF ALL BITS TRANSFERRED
          if ((data_idx > 39) & (cnt_1mhz == 0)) begin // IDX loops above 39 after 0 and only occur first cycle after.
            
            fin_data <= raw_data[39:8];
            if (int_checksum != (sum_data[7:0] + sum_data[9:8] + raw_data[7:0])) begin // wrap around the first two bits of sum data and add with checksum.
              raw_data <= 40'b0; // Error in checksum, reset values to zero indicating error.
              fin_data <= raw_data[39:8];
                  
            end
            cnt_1mhz <= cnt_1mhz + 1; // 1 mhz count up
          end
          
          // BIT = 0
          else if ( (prev_cnt >= 22) & (prev_cnt <= 32) ) begin // Bit will be a 0 (26-28us), with 4us leeway.
            $display("Bit %d = 0,  cnt: %d, prev_cnt: %d, all bits: %b", data_idx, cnt_1mhz, prev_cnt, raw_data );
            raw_data[data_idx] <= 0; // Set value into correct position
            data_idx <= data_idx -1; 
            prev_cnt <= 0;
            sum_data <= (raw_data[39:32] + raw_data[31:24] + raw_data[23:16] + raw_data[15:8]); // Update with new sum
          end
          
          // BIT = 1
          else if ( (prev_cnt >= 66) & (prev_cnt <= 74) ) begin // Bit will be a 1 (70us), with 4us leeway.
            $display("Bit %d = 1,  cnt: %d, prev_cnt: %d, all bits: %b", data_idx, cnt_1mhz, prev_cnt, raw_data );
            raw_data[data_idx] <= 1; // Set value into correct position
            data_idx <= data_idx -1; 
            prev_cnt <= 0;
            sum_data <= (raw_data[39:32] + raw_data[31:24] + raw_data[23:16] + raw_data[15:8]); // Update with new sum
          end
          
          // ALL COMPLETE, RESET REQUIRED VALUES FOR NEXT TRIGGER
          else if (data_idx > 39) begin
            $display("RESETTING VALUES");
            clk_cnt <= 7'b0; // Start clock counter at zero
            clk_1mhz_en <= 1'b0;
            cnt_1mhz <= 21'b0; // Start value at zero
            // trig_timer <= 21'd1999999; // Set target trigger signal time to 2 seconds.
            trig_timer <= 21'd18001; // For testing sake, set trig far lower.
            bidir_en <= 1; // Module becomes sender again
            dout <= 1;
            raw_data <= 40'b0;
            data_idx <= 6'd39; // Starts at lhs to mimic how its received.
            comm_status <= 3'b0;
            sum_data <= 10'b0;
            prev_cnt<= 21'b0;
            
          end        
        end
        else
          cnt_1mhz <= cnt_1mhz + 1; // 1 mhz count up
      end
      else
        cnt_1mhz <= cnt_1mhz + 1; // 1 mhz count up
    end
  end
  
  // Replaces the need to reset counter manually each time.
  always @(bidir) begin
    prev_cnt = cnt_1mhz;
    cnt_1mhz <= 0;
    $display("line switch"); // For identifying issue with second loop and count reset/high-low switching.
  end    
  
endmodule